<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hehelv.github.io/</id>
    <title>💤ISpiker</title>
    <updated>2020-01-18T13:56:21.655Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hehelv.github.io/"/>
    <link rel="self" href="https://hehelv.github.io//atom.xml"/>
    <subtitle>The proof is in the pudding.</subtitle>
    <logo>https://hehelv.github.io//images/avatar.png</logo>
    <icon>https://hehelv.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, 💤ISpiker</rights>
    <entry>
        <title type="html"><![CDATA[八皇后]]></title>
        <id>https://hehelv.github.io//post/ba-huang-hou</id>
        <link href="https://hehelv.github.io//post/ba-huang-hou">
        </link>
        <updated>2020-01-18T13:47:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="代码">代码：</h1>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,a[50],total;
int b[100],c[100],d[100];//b,c,d分别代表列，主对角线，副对角线，初始值为0，当有一个皇后出现时，需要将其所占的列，主，副对角线标记为1

void dfs(int i)//这里i代表的是第i个皇后
{
    if(i&gt;n)//i&gt;n时说明已经有了一种解法
    {
        total++;
        if(total&lt;=3)
        {
            for(int j=1;j&lt;=n;j++)
            {
                printf(&quot;%d &quot;,a[j]);
            }
            printf(&quot;\n&quot;);
        }
        return;
    }
    for(int j=1;j&lt;=n;j++)
    {
        if(!b[j]&amp;&amp;!c[i+j]&amp;&amp;!d[i-j+n])//（i，j）所占列，主，副对角线都未被标记的情况下
        {
            a[i] = j;
            b[j] = 1;
            c[i+j] = 1;
            d[i-j+n] = 1;//打标记
            dfs(i+1);
            b[j] = 0;
            c[i+j] = 0;
            d[i-j+n] = 0;//回溯的时候，需要把标记去掉
        }
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    dfs(1);
    printf(&quot;%d&quot;,total);
    return 0;
}
</code></pre>
<ul>
<li>需要注意的几点性质（关于这个性质可以很容易画图得到）：<br>
1.主对角线上所有点的坐标x+y相等（这里的主对角线表示的是左下到右上）<br>
2.副对角线上所有点的坐标x-y相等（副对角线表示左上到右下）<br>
3.代码中d[i-j+n]，加n的原因是i-j会出现负数，而我们对其加任意大小的数不会改变她表示副对角线的唯一性，至于加n的原因是i-j最大的负数是1-n，所以我们只需要加n即可。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找（binary_search）]]></title>
        <id>https://hehelv.github.io//post/er-fen-cha-zhao-binary_search</id>
        <link href="https://hehelv.github.io//post/er-fen-cha-zhao-binary_search">
        </link>
        <updated>2020-01-14T03:50:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一个例子">一个例子：</h1>
<p><img src="https://hehelv.github.io//post-images/1578974006618.png" alt=""><br>
根据这个问题很容易想到用一个四重循环来写，通过暴力求解得方法，代码如下：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int MAX_N = 50;

int main()
{
    int n,m,k[MAX_N];

    bool f = false;//判断是否能找到和为m得四个数字
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d&quot;,k[i]);
    }

    for(int a=0;a&lt;n;a++)
    {
        for(int b=0;b&lt;n;b++)
        {
            for(int c=0;c&lt;n;c++)
            {
                for(int d=0;d&lt;n;d++)
                {
                    if(k[a]+k[b]+k[c]+k[d] == m)
                    {
                        f = true;
                    }
                }
            }
        }
    }
    if(f)
        puts(&quot;yes&quot;);
    else 
        puts(&quot;no&quot;);
    return 0;
}

/*
n=3
m=9
k={1,3,5}

no
*/

</code></pre>
<h1 id="更快的方法二分查找">更快的方法：二分查找</h1>
<p>我们发现用四重循环的时间复杂度为O(n<sup>4)，我们利用二分查找来代替最里面那一层的循环，在用二分查找之前需要我们排序，而排序的时间复杂度为O(nlogn),二分查找的时间复杂度为O(logn),代替最里层的循环后，总时间复杂度为O(n</sup>3logn),所以时间复杂度为O(n^3logn)。</p>
<ul>
<li>代码如下：</li>
</ul>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int MAX_N = 50;
int n,m,k[MAX_N];

bool Binary_Search(int x)
{
    int l=0,r=n;//这里要求r必须等于n，也就是说要多出一个无用的数组位，因为当x=k[n-1]时，l最终会等于n-1，如果r=n-1则会提前退出循环
    while(r-l &gt;= 1)
    {
        int i = (r+l)/2;
        if(k[i] == x) return true;
        else if(k[i] &lt; x) l = i+1;
        else r = i;
    }
    return false;
}

int main()
{
    bool f = false;//判断是否能找到和为m得四个数字

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d&quot;,&amp;k[i]);
    }
    sort(k,k+n);//将数组排序

    for(int a=0;a&lt;n;a++)
    {
        for(int b=0;b&lt;n;b++)
        {
            for(int c=0;c&lt;n;c++)
            {
                if(Binary_Search(m-k[a]-k[b]-k[c]))
                    f = true;
            }
        }
    }
    if(f)
        puts(&quot;yes&quot;);
    else 
        puts(&quot;no&quot;);
    return 0;
}

/*
n=3
m=9
k={1,3,5}

no
*/

</code></pre>
<h1 id="再优化">再优化：</h1>
<ul>
<li>再使用了二分查找之后时间复杂度为O(n^3logn),可以利用二分查找进一步的优化，我们可以将四重循环的内两层循环换成二分查找，这时候的式子为k[c]+k[d] = m-k[a]-k[b],我们需要一个数组来保存k[c]+k[d]的所有情况。</li>
<li>这时候的时间复杂度：</li>
<li>1.排序时间复杂度：O(n^2logn)</li>
<li>2.循环加二分查找复杂度：O(n^2logn)</li>
<li>到这里我们可以发现，再去一层循环已经没有意义了，因为此时的数组排序时间复杂度为O(n^3logn).</li>
<li>代码如下：</li>
</ul>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int MAX_N = 50;
int n,m,k[MAX_N];
int kk[MAX_N*MAX_N];

bool Binary_Search(int x)
{
    int l=0,r=n;//这里要求r必须等于n，也就是说要多出一个无用的数组位，因为但x=k[n-1]时，l最终会等于n-1，如果r=n-1则会提前退出循环
    while(r-l &gt;= 1)
    {
        int i = (r+l)/2;
        if(kk[i] == x) return true;
        else if(kk[i] &lt; x) l = i+1;
        else r = i;
    }
    return false;
}

int main()
{
    bool f = false;//判断是否能找到和为m得四个数字

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d&quot;,&amp;k[i]);
    }
    for(int c=0;c&lt;n;c++)
    {
        for(int d=0;d&lt;n;d++)
        {
            kk[c*n+d] = k[c] + k[d];
        }
    }

    sort(kk,kk+n*n);//将数组排序

    for(int a=0;a&lt;n;a++)
    {
        for(int b=0;b&lt;n;b++)
        {
            if(Binary_Search(m-k[a]-k[b]))
                    f = true;
        }
    }
    if(f)
        puts(&quot;yes&quot;);
    else 
        puts(&quot;no&quot;);
    return 0;
}
/*
n=3
m=9
k={1,3,5}

no
*/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ants问题]]></title>
        <id>https://hehelv.github.io//post/ants-wen-ti</id>
        <link href="https://hehelv.github.io//post/ants-wen-ti">
        </link>
        <updated>2020-01-10T12:56:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题：</h1>
<figure data-type="image" tabindex="1"><img src="https://hehelv.github.io//post-images/1578666147784.png" alt=""></figure>
<ul>
<li>解决思路：</li>
<li>我们想考虑一下如果两只蚂蚁相遇了的情形：</li>
<li><img src="https://hehelv.github.io//post-images/1578666310683.png" alt=""></li>
<li>发现每只蚂蚁都可以看成相遇后仍然不调转方向，因为问题本身不关注个体的蚂蚁，在我们看来所有的蚂蚁都是一样的。</li>
</ul>
<h1 id="代码如下">代码如下：</h1>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
#define MAX_N 100

int max(int x,int y)
{
    if(x-y&gt;0)
        return x;
    else return y;
}

int min(int x,int y)
{
    if(x-y&gt;0)
        return y;
    else return x;
}

int main()
{
    int L,n;
    int minT,maxT;
    int a[MAX_N];  //用来收集每只蚂蚁的信息
    scanf(&quot;%d%d&quot;,&amp;L,&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    for(int i=1;i&lt;=n;i++)
    {
        minT = max(minT,min(a[i],L-a[i]));
        maxT = max(maxT,max(a[i],L-a[i]));
    }
    printf(&quot;min:%d max:%d&quot;,minT,maxT);
    return 0;
}
/*
10 3
2
6
7
min:4 max:8
*/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DFS（Depth first search）与BFS（Breadth First Search）]]></title>
        <id>https://hehelv.github.io//post/dfsdepth-first-search</id>
        <link href="https://hehelv.github.io//post/dfsdepth-first-search">
        </link>
        <updated>2020-01-09T09:12:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="深度优先搜索模型">深度优先搜索模型：</h1>
<pre><code class="language-c">void dfs(int step)
{
    判断边界
    尝试每一种可能 for(i=1;i&lt;=n;i++)
    {
        继续下一步 dfs(step+1);
    }
    返回
}
</code></pre>
<p>对于深度优先搜索，首先要明白当前怎么做，然后直接dfs(step+1)，做下一步即可。<br>
例子：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速排序（quicksort）]]></title>
        <id>https://hehelv.github.io//post/kuai-su-pai-xu</id>
        <link href="https://hehelv.github.io//post/kuai-su-pai-xu">
        </link>
        <updated>2020-01-04T07:35:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>👏这个笔记是看了《啊哈！算法》之后，自己的一些小总结。</strong></p>
<h1 id="快速排序">快速排序：</h1>
<ul>
<li>还是通过一个例子来说明：</li>
<li>有这样一个序列：3，2，1，5，4</li>
<li>要求从小到大排序</li>
<li>快速排序的想法：</li>
<li>1.先找一个基准数，这里默认为第一个数3；</li>
<li>2.然后将比3小的数移到3的左边，比3大的数移到3的右边；</li>
<li>3.后面用递归将3左边和右边的数组在实现一次上述操作。</li>
<li><img src="https://hehelv.github.io//post-images/1578128045451.gif" alt=""></li>
</ul>
<h1 id="代码如下">代码如下：</h1>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int a[101],n;

void quicksort(int left,int right)
	{
		int i,j,t,temp;
		i = left;
		j = right;
		if(i &gt; j)
			return;
		temp = a[left];
		
		while(i!=j)
		{
			while(a[j]&gt;=temp &amp;&amp; i&lt;j)
			{
				j--;
			}
			while(a[i]&lt;=temp &amp;&amp; i&lt;j)
			{
				i++;
			}
			if(i!=j)
			{
				t = a[i];
				a[i] = a[j];
				a[j] = t;
			}
		}

		
		a[left] = a[i];
		a[i] = temp;
		
		quicksort(left,i-1);
		quicksort(i+1,right);
	}

int main()
{
	int i,j;
	scanf(&quot;%d&quot;,&amp;n);
	for(i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
	}
	quicksort(1,n);
	for(i=1;i&lt;=n;i++)
	{
		printf(&quot;%d &quot;,a[i]);
	}
	return 0;
}
/*
示例输出：
5
3 3 1 2 5
1 2 3 3 5

5
3 2 1 5 4
1 2 3 4 5
*/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简陋的桶排序，冒泡排序。。。]]></title>
        <id>https://hehelv.github.io//post/algorithm</id>
        <link href="https://hehelv.github.io//post/algorithm">
        </link>
        <updated>2020-01-01T04:02:55.000Z</updated>
        <content type="html"><![CDATA[<p><strong>👏这个笔记是看了《啊哈！算法》之后，自己的一些小总结。</strong></p>
<h1 id="1一个简陋的桶排序">1.一个简陋的桶排序：</h1>
<p>在说桶排序算法时，我们来通过一个例子来大概了解一下桶排序是什么：</p>
<ul>
<li>对8，5，5，3，2这五个数进行从大到小的排序：</li>
<li><strong>想法如下：</strong><br>
1.构建一个数组a[10]，并将其<strong>置零</strong>。<br>
2.对每个出现的数，在数组对应的位置上加一。（出现一次就加一，例子中5出现了两次，那么a[5] = 2）<br>
3.然后将数组倒序输出，如果<strong>a[i] = 0</strong>，则不输出，若不为0则输出i，且输出一次将数组减一。</li>
<li><strong>代码如下：</strong><pre><code class="language-c++">#include &lt;stdio.h&gt;
int main()
{
int a[11],i,j,t;
for(i=0;i&lt;=10;i++)
    a[i]=0; //初始化为0
for(i=1;i&lt;=5;i++) //循环读入5个数
{
    scanf(&quot;%d&quot;,&amp;t); //把每一个数读到变量t中
    a[t]++; //进行计数
}
for(i=0;i&lt;=10;i++) //依次判断a[0]~a[10]
    for(j=1;j&lt;=a[i];j++) //出现了几次就打印几次
        printf(&quot;%d &quot;,i);
return 0;
}
</code></pre>
</li>
<li>但这个方法明显有很大的缺陷：</li>
<li>1.例如当要求排序的数只有3,5,999时，我们却需要创建一个a[1000]的数组，造成了极大的浪费；</li>
<li>2.但要求比较的数不止是整数时，也不能使用这个算法；</li>
<li>所以这里叫做<strong>简陋的桶排序</strong>，真正的桶排序会解决上述问题，这里先不介绍。</li>
</ul>
<h1 id="2冒泡排序">2.冒泡排序：</h1>
<p>依旧从一个例子出发：</p>
<ul>
<li>
<p>对12，35，99，18，76这五个数进行排序：</p>
</li>
<li>
<p>冒泡的基本思想是：<strong>每比较相邻的两个元素，如果他们顺序错误就把他们交换过来。</strong></p>
</li>
<li>
<p>在例子中，将第一位与第二位比较，12小，交换位置，35到第一位，12到第二位，将第二位继续与第三位相比，再次交换顺序，一直进行下去，直到12在第五位（即最后一位），这个数组会变成：35，99，18，76，12（此时最小的数已到达第五位了）</p>
</li>
<li>
<p>再进行第二次冒泡，将第一位与第二位比较，35小，交换顺序，第二位与第三位比较，18小，不交换顺序，第三位与第四位比较，18小，交换顺序，此时数组为：99，35，76，18，12（此时第二小的数已经到达第四位）</p>
</li>
<li>
<p>再对后面的数进行操作，数组最终会变成：99，76，35，18，12</p>
</li>
<li>
<figure data-type="image" tabindex="1"><img src="https://hehelv.github.io//post-images/1578132651155.gif" alt=""></figure>
</li>
<li>
<p><strong>我们来总结一下：</strong></p>
</li>
<li>
<p>1.每进行一次冒泡，就有一个数归位，例如第一次冒泡只能将第五位归位，第二次将第四位归位，后面以此类推。</p>
</li>
<li>
<p>2.对于n个数的排序，我们只需要将n-1个数进行归位。</p>
</li>
<li>
<p>依照这个思想，对于任意n个数的排序，代码如下：</p>
</li>
</ul>
<pre><code class="language-c++">#include&lt;stdio.h&gt;
int main()
{
	int a[100],i,j,t,n;
	scanf(&quot;%d&quot;,&amp;n);     //输入一个数n，表示接下来有n个数
	for(i=1;i&lt;=n;i++)   //循环读入n个数到数组a中
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
	}
    //冒泡排序的核心部分
	for(i=1;i&lt;=n-1;i++)     //n个数排序，只用进行n-1趟
	{
		for(j=1;j&lt;=n-i;j++)
		{
			if(a[j]&lt;a[j+1])
			{
				t = a[j+1]; a[j+1] = a[j]; a[j] = t;    //比较大小并交换
				}	
		}
	}
	for(i=1;i&lt;=n;i++)
		printf(&quot;%d &quot;,a[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello world]]></title>
        <id>https://hehelv.github.io//post/hello-world</id>
        <link href="https://hehelv.github.io//post/hello-world">
        </link>
        <updated>2020-01-01T03:39:09.000Z</updated>
        <content type="html"><![CDATA[<p>😀<strong>First time write here!</strong></p>
<pre><code>    建Blog的目的就是为了用一些简短的方式把自己学的知识记录下来，以及写些琐碎的想法，其他别无他想，其实能把这两点做好就已经十分满足了。                          ————2020.01.01
</code></pre>
]]></content>
    </entry>
</feed>