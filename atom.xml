<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hehelv.github.io/</id>
    <title>💤ISpiker</title>
    <updated>2020-03-08T01:42:44.641Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hehelv.github.io/"/>
    <link rel="self" href="https://hehelv.github.io//atom.xml"/>
    <subtitle>The proof is in the pudding.</subtitle>
    <logo>https://hehelv.github.io//images/avatar.png</logo>
    <icon>https://hehelv.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, 💤ISpiker</rights>
    <entry>
        <title type="html"><![CDATA[15-框架架构]]></title>
        <id>https://hehelv.github.io//post/15-kuang-jia-jia-gou</id>
        <link href="https://hehelv.github.io//post/15-kuang-jia-jia-gou">
        </link>
        <updated>2020-03-03T03:21:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="15-框架架构">15-框架架构</h1>
<h2 id="scrapy框架介绍">Scrapy框架介绍：</h2>
<p>写一个爬虫，需要做很多的事情。比如：发送网络请求、数据解析、数据存储、反反爬虫机制（更换ip代理、设置请求头等）、异步请求等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此<code>Scrapy</code>把一些基础的东西封装好了，在他上面写爬虫可以变的更加的高效（爬取效率和开发效率）。因此真正在公司里，一些上了量的爬虫，都是使用<code>Scrapy</code>框架来解决。</p>
<h2 id="scrapy架构图">Scrapy架构图：</h2>
<ol>
<li>流程图（1）：<br>
<img src="../assets/scrapy_all.png" alt="img"></li>
<li>流程图（2）：<br>
<img src="../assets/884863172-5985e0b48edf9.png" alt="img"></li>
</ol>
<h2 id="scrapy框架模块功能">Scrapy框架模块功能：</h2>
<ol>
<li><code>Scrapy Engine（引擎）</code>：<code>Scrapy</code>框架的核心部分。负责在<code>Spider</code>和<code>ItemPipeline</code>、<code>Downloader</code>、<code>Scheduler</code>中间通信、传递数据等。</li>
<li><code>Spider（爬虫）</code>：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是我们需要的，都是由程序员自己决定。</li>
<li><code>Scheduler（调度器）</code>：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。</li>
<li><code>Downloader（下载器）</code>：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。</li>
<li><code>Item Pipeline（管道）</code>：负责将<code>Spider（爬虫）</code>传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。</li>
<li><code>Downloader Middlewares（下载中间件）</code>：可以扩展下载器和引擎之间通信功能的中间件。</li>
<li><code>Spider Middlewares（Spider中间件）</code>：可以扩展引擎和爬虫之间通信功能的中间件。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[14-图形验证码识别]]></title>
        <id>https://hehelv.github.io//post/13-tu-xing-yan-zheng-ma-shi-bie</id>
        <link href="https://hehelv.github.io//post/13-tu-xing-yan-zheng-ma-shi-bie">
        </link>
        <updated>2020-03-03T03:14:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="14-图形验证码识别">14-图形验证码识别</h1>
<p>阻碍我们爬虫的。有时候正是在登录或者请求一些数据时候的图形验证码。因此这里我们讲解一种能将图片翻译成文字的技术。将图片翻译成文字一般被成为光学文字识别（Optical Character Recognition），简写为<code>OCR</code>。实现<code>OCR</code>的库不是很多，特别是开源的。因为这块存在一定的技术壁垒（需要大量的数据、算法、机器学习、深度学习知识等），并且如果做好了具有很高的商业价值。因此开源的比较少。这里介绍一个比较优秀的图像识别开源库：Tesseract。</p>
<h2 id="tesseract">Tesseract：</h2>
<p>Tesseract是一个OCR库，目前由谷歌赞助。Tesseract是目前公认最优秀、最准确的开源OCR库。Tesseract具有很高的识别度，也具有很高的灵活性，他可以通过训练识别任何字体。</p>
<h3 id="安装">安装：</h3>
<h4 id="windows系统">Windows系统：</h4>
<p>在以下链接下载可执行文件，然后一顿点击下一步安装即可（放在不需要权限的纯英文路径下）：<br>
https://github.com/tesseract-ocr/</p>
<h4 id="linux系统">Linux系统：</h4>
<p>可以在以下链接下载源码自行编译。<br>
https://github.com/tesseract-ocr/tesseract/wiki/Compiling<br>
或者在<code>ubuntu</code>下通过以下命令进行安装：</p>
<pre><code class="language-shell">sudo apt install tesseract-ocr
</code></pre>
<h4 id="mac系统">Mac系统：</h4>
<p>用<code>Homebrew</code>即可方便安装：</p>
<pre><code class="language-shell">brew install tesseract
</code></pre>
<h4 id="设置环境变量">设置环境变量：</h4>
<p>安装完成后，如果想要在命令行中使用<code>Tesseract</code>，那么应该设置环境变量。<code>Mac</code>和<code>Linux</code>在安装的时候就默认已经设置好了。在<code>Windows</code>下把<code>tesseract.exe</code>所在的路径添加到<code>PATH</code>环境变量中。</p>
<p>还有一个环境变量需要设置的是，要把训练的数据文件路径也放到环境变量中。<br>
在环境变量中，添加一个<code>TESSDATA_PREFIX=C:\path_to_tesseractdata\teseractdata</code>。</p>
<h3 id="在命令行中使用tesseract识别图像">在命令行中使用tesseract识别图像：</h3>
<p>如果想要在<code>cmd</code>下能够使用<code>tesseract</code>命令，那么需要把<code>tesseract.exe</code>所在的目录放到<code>PATH</code>环境变量中。然后使用命令：<code>tesseract 图片路径 文件路径</code>。<br>
示例：</p>
<pre><code class="language-shell">tesseract a.png a
</code></pre>
<p>那么就会识别出<code>a.png</code>中的图片，并且把文字写入到<code>a.txt</code>中。如果不想写入文件直接想显示在终端，那么不要加文件名就可以了。</p>
<h3 id="在代码中使用tesseract识别图像">在代码中使用tesseract识别图像：</h3>
<p>在<code>Python</code>代码中操作<code>tesseract</code>。需要安装一个库，叫做<code>pytesseract</code>。通过<code>pip</code>的方式即可安装：</p>
<pre><code>pip install pytesseract
</code></pre>
<p>并且，需要读取图片，需要借助一个第三方库叫做<code>PIL</code>。通过<code>pip list</code>看下是否安装。如果没有安装，通过<code>pip</code>的方式安装：</p>
<pre><code>pip install PIL
</code></pre>
<p>使用<code>pytesseract</code>将图片上的文字转换为文本文字的示例代码如下：</p>
<pre><code class="language-python"># 导入pytesseract库
import pytesseract
# 导入Image库
from PIL import Image

# 指定tesseract.exe所在的路径
pytesseract.pytesseract.tesseract_cmd = r'D:\ProgramApp\TesseractOCR\tesseract.exe'

# 打开图片
image = Image.open(&quot;a.png&quot;)
# 调用image_to_string将图片转换为文字
text = pytesseract.image_to_string(image)
print(text)
</code></pre>
<h2 id="用pytesseract处理拉勾网图形验证码">用<code>pytesseract</code>处理拉勾网图形验证码：</h2>
<pre><code class="language-python">import pytesseract
from urllib import request
from PIL import Image
import time


pytesseract.pytesseract.tesseract_cmd = r&quot;D:\ProgramApp\TesseractOCR\tesseract.exe&quot;


while True:
    captchaUrl = &quot;https://passport.lagou.com/vcode/create?from=register&amp;refresh=1513081451891&quot;
    request.urlretrieve(captchaUrl,'captcha.png')
    image = Image.open('captcha.png')
    text = pytesseract.image_to_string(image,lang='eng')
    print(text)
    time.sleep(2)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[13-动态网页爬虫]]></title>
        <id>https://hehelv.github.io//post/13-dong-tai-wang-ye-pa-chong</id>
        <link href="https://hehelv.github.io//post/13-dong-tai-wang-ye-pa-chong">
        </link>
        <updated>2020-03-03T03:14:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="13-动态网页爬虫">13-动态网页爬虫</h1>
<h2 id="什么是ajax">什么是AJAX：</h2>
<p>AJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页页面。因为传统的在传输数据格式方面，使用的是<code>XML</code>语法。因此叫做<code>AJAX</code>，其实现在数据交互基本上都是使用<code>JSON</code>。使用AJAX加载的数据，即使使用了JS，将数据渲染到了浏览器中，在<code>右键-&gt;查看网页源代码</code>还是不能看到通过ajax加载的数据，只能看到使用这个url加载的html代码。</p>
<h2 id="获取ajax数据的方式">获取ajax数据的方式：</h2>
<ol>
<li>直接分析ajax调用的接口。然后通过代码请求这个接口。</li>
<li>使用Selenium+chromedriver模拟浏览器行为获取数据。</li>
</ol>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分析接口</td>
<td>直接可以请求到数据。不需要做一些解析工作。代码量少，性能高。</td>
<td>分析接口比较复杂，特别是一些通过js混淆的接口，要有一定的js功底。容易被发现是爬虫。</td>
</tr>
<tr>
<td>selenium</td>
<td>直接模拟浏览器的行为。浏览器能请求到的，使用selenium也能请求到。爬虫更稳定。</td>
<td>代码量多。性能低。</td>
</tr>
</tbody>
</table>
<h2 id="seleniumchromedriver获取动态数据">Selenium+chromedriver获取动态数据：</h2>
<p><code>Selenium</code>相当于是一个机器人。可以模拟人类在浏览器上的一些行为，自动处理浏览器上的一些行为，比如点击，填充数据，删除cookie等。<code>chromedriver</code>是一个驱动<code>Chrome</code>浏览器的驱动程序，使用他才可以驱动浏览器。当然针对不同的浏览器有不同的driver。以下列出了不同浏览器及其对应的driver：</p>
<ol>
<li>Chrome：https://sites.google.com/a/chromium.org/chromedriver/downloads</li>
<li>Firefox：https://github.com/mozilla/geckodriver/releases</li>
<li>Edge：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/</li>
<li>Safari：https://webkit.org/blog/6900/webdriver-support-in-safari-10/</li>
</ol>
<h2 id="安装selenium和chromedriver">安装Selenium和chromedriver：</h2>
<ol>
<li>
<p>安装</p>
<pre><code>Selenium
</code></pre>
<p>：</p>
<pre><code>Selenium
</code></pre>
<p>有很多语言的版本，有java、ruby、python等。我们下载python版本的就可以了。</p>
<pre><code class="language-shell"> pip install selenium
</code></pre>
</li>
<li>
<p>安装<code>chromedriver</code>：下载完成后，放到不需要权限的纯英文目录下就可以了。</p>
</li>
</ol>
<h3 id="快速入门">快速入门：</h3>
<p>现在以一个简单的获取百度首页的例子来讲下<code>Selenium</code>和<code>chromedriver</code>如何快速入门：</p>
<pre><code class="language-python">from selenium import webdriver

# chromedriver的绝对路径
driver_path = r'D:\ProgramApp\chromedriver\chromedriver.exe'

# 初始化一个driver，并且指定chromedriver的路径
driver = webdriver.Chrome(executable_path=driver_path)
# 请求网页
driver.get(&quot;https://www.baidu.com/&quot;)
# 通过page_source获取网页源代码
print(driver.page_source)
</code></pre>
<h3 id="selenium常用操作">selenium常用操作：</h3>
<p>更多教程请参考：http://selenium-python.readthedocs.io/installation.html#introduction</p>
<h4 id="关闭页面">关闭页面：</h4>
<ol>
<li><code>driver.close()</code>：关闭当前页面。</li>
<li><code>driver.quit()</code>：退出整个浏览器。</li>
</ol>
<h4 id="定位元素">定位元素：</h4>
<ol>
<li>
<pre><code>find_element_by_id
</code></pre>
<p>：根据id来查找某个元素。等价于：</p>
<pre><code class="language-python"> submitTag = driver.find_element_by_id('su')
 submitTag1 = driver.find_element(By.ID,'su')
</code></pre>
</li>
<li>
<pre><code>find_element_by_class_name
</code></pre>
<p>：根据类名查找元素。 等价于：</p>
<pre><code class="language-python"> submitTag = driver.find_element_by_class_name('su')
 submitTag1 = driver.find_element(By.CLASS_NAME,'su')
</code></pre>
</li>
<li>
<pre><code>find_element_by_name
</code></pre>
<p>：根据name属性的值来查找元素。等价于：</p>
<pre><code class="language-python"> submitTag = driver.find_element_by_name('email')
 submitTag1 = driver.find_element(By.NAME,'email')
</code></pre>
</li>
<li>
<pre><code>find_element_by_tag_name
</code></pre>
<p>：根据标签名来查找元素。等价于：</p>
<pre><code class="language-python"> submitTag = driver.find_element_by_tag_name('div')
 submitTag1 = driver.find_element(By.TAG_NAME,'div')
</code></pre>
</li>
<li>
<pre><code>find_element_by_xpath
</code></pre>
<p>：根据xpath语法来获取元素。等价于：</p>
<pre><code class="language-python"> submitTag = driver.find_element_by_xpath('//div')
 submitTag1 = driver.find_element(By.XPATH,'//div')
</code></pre>
</li>
<li>
<p><code>find_element_by_css_selector</code>：根据css选择器选择元素。等价于：</p>
<pre><code class="language-python"> submitTag = driver.find_element_by_css_selector('//div')
 submitTag1 = driver.find_element(By.CSS_SELECTOR,'//div')
</code></pre>
<p>要注意，<code>find_element</code>是获取第一个满足条件的元素。<code>find_elements</code>是获取所有满足条件的元素。</p>
</li>
</ol>
<h4 id="操作表单元素">操作表单元素：</h4>
<ol>
<li>
<p>操作输入框：分为两步。第一步：找到这个元素。第二步：使用<code>send_keys(value)</code>，将数据填充进去。示例代码如下：</p>
<pre><code class="language-python"> inputTag = driver.find_element_by_id('kw')
 inputTag.send_keys('python')
</code></pre>
<p>使用<code>clear</code>方法可以清除输入框中的内容。示例代码如下：</p>
<pre><code class="language-python"> inputTag.clear()
</code></pre>
</li>
<li>
<p>操作checkbox：因为要选中<code>checkbox</code>标签，在网页中是通过鼠标点击的。因此想要选中<code>checkbox</code>标签，那么先选中这个标签，然后执行<code>click</code>事件。示例代码如下：</p>
<pre><code class="language-python"> rememberTag = driver.find_element_by_name(&quot;rememberMe&quot;)
 rememberTag.click()
</code></pre>
</li>
<li>
<p>选择select：select元素不能直接点击。因为点击后还需要选中元素。这时候selenium就专门为select标签提供了一个类<code>selenium.webdriver.support.ui.Select</code>。将获取到的元素当成参数传到这个类中，创建这个对象。以后就可以使用这个对象进行选择了。示例代码如下：</p>
<pre><code class="language-python"> from selenium.webdriver.support.ui import Select
 # 选中这个标签，然后使用Select创建对象
 selectTag = Select(driver.find_element_by_name(&quot;jumpMenu&quot;))
 # 根据索引选择
 selectTag.select_by_index(1)
 # 根据值选择
 selectTag.select_by_value(&quot;http://www.95yueba.com&quot;)
 # 根据可视的文本选择
 selectTag.select_by_visible_text(&quot;95秀客户端&quot;)
 # 取消选中所有选项
 selectTag.deselect_all()
</code></pre>
</li>
<li>
<p>操作按钮：操作按钮有很多种方式。比如单击、右击、双击等。这里讲一个最常用的。就是点击。直接调用<code>click</code>函数就可以了。示例代码如下：</p>
<pre><code class="language-python"> inputTag = driver.find_element_by_id('su')
 inputTag.click()
</code></pre>
</li>
</ol>
<h4 id="行为链">行为链：</h4>
<p>有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类<code>ActionChains</code>来完成。比如现在要将鼠标移动到某个元素上并执行点击事件。那么示例代码如下：</p>
<pre><code class="language-python">inputTag = driver.find_element_by_id('kw')
submitTag = driver.find_element_by_id('su')

actions = ActionChains(driver)
actions.move_to_element(inputTag)
actions.send_keys_to_element(inputTag,'python')
actions.move_to_element(submitTag)
actions.click(submitTag)
actions.perform()
</code></pre>
<p>还有更多的鼠标相关的操作。</p>
<ul>
<li>click_and_hold(element)：点击但不松开鼠标。</li>
<li>context_click(element)：右键点击。</li>
<li>double_click(element)：双击。 更多方法请参考：http://selenium-python.readthedocs.io/api.html</li>
</ul>
<h4 id="cookie操作">Cookie操作：</h4>
<ol>
<li>
<p>获取所有的</p>
<pre><code>cookie
</code></pre>
<p>：</p>
<pre><code class="language-python"> for cookie in driver.get_cookies():
     print(cookie)
</code></pre>
</li>
<li>
<p>根据cookie的key获取value：</p>
<pre><code class="language-python"> value = driver.get_cookie(key)
</code></pre>
</li>
<li>
<p>删除所有的cookie：</p>
<pre><code class="language-python"> driver.delete_all_cookies()
</code></pre>
</li>
<li>
<p>删除某个</p>
<pre><code>cookie
</code></pre>
<p>：</p>
<pre><code class="language-python"> driver.delete_cookie(key)
</code></pre>
</li>
</ol>
<h4 id="页面等待">页面等待：</h4>
<p>现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。为了解决这个问题。所以 Selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。</p>
<ol>
<li>
<p>隐式等待：调用<code>driver.implicitly_wait</code>。那么在获取不可用的元素之前，会先等待10秒中的时间。示例代码如下：</p>
<pre><code class="language-python">driver = webdriver.Chrome(executable_path=driver_path)
driver.implicitly_wait(10)
# 请求网页
driver.get(&quot;https://www.douban.com/&quot;)
</code></pre>
</li>
<li>
<p>显示等待：显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用<code>selenium.webdriver.support.excepted_conditions</code>期望的条件和<code>selenium.webdriver.support.ui.WebDriverWait</code>来配合完成。示例代码如下：</p>
<pre><code class="language-python"> from selenium import webdriver
 from selenium.webdriver.common.by import By
 from selenium.webdriver.support.ui import WebDriverWait
 from selenium.webdriver.support import expected_conditions as EC

 driver = webdriver.Firefox()
 driver.get(&quot;http://somedomain/url_that_delays_loading&quot;)
 try:
     element = WebDriverWait(driver, 10).until(
         EC.presence_of_element_located((By.ID, &quot;myDynamicElement&quot;))
     )
 finally:
     driver.quit()
</code></pre>
</li>
<li>
<p>一些其他的等待条件：</p>
<ul>
<li>
<p>presence_of_element_located：某个元素已经加载完毕了。</p>
</li>
<li>
<p>presence_of_all_emement_located：网页中所有满足条件的元素都加载完毕了。</p>
</li>
<li>
<p>element_to_be_cliable：某个元素是可以点击了。</p>
<p>更多条件请参考：http://selenium-python.readthedocs.io/waits.html</p>
</li>
</ul>
</li>
</ol>
<h4 id="切换页面">切换页面：</h4>
<p>有时候窗口中有很多子tab页面。这时候肯定是需要进行切换的。<code>selenium</code>提供了一个叫做<code>switch_to_window</code>来进行切换，具体切换到哪个页面，可以从<code>driver.window_handles</code>中找到。示例代码如下：</p>
<pre><code class="language-python"># 打开一个新的页面
self.driver.execute_script(&quot;window.open('&quot;+url+&quot;')&quot;)
# 切换到这个新的页面中
self.driver.switch_to_window(self.driver.window_handles[1])
</code></pre>
<h4 id="设置代理ip">设置代理ip：</h4>
<p>有时候频繁爬取一些网页。服务器发现你是爬虫后会封掉你的ip地址。这时候我们可以更改代理ip。更改代理ip，不同的浏览器有不同的实现方式。这里以<code>Chrome</code>浏览器为例来讲解：</p>
<pre><code class="language-python">from selenium import webdriver

options = webdriver.ChromeOptions()
options.add_argument(&quot;--proxy-server=http://110.73.2.248:8123&quot;)
driver_path = r&quot;D:\ProgramApp\chromedriver\chromedriver.exe&quot;
driver = webdriver.Chrome(executable_path=driver_path,chrome_options=options)

driver.get('http://httpbin.org/ip')
</code></pre>
<h4 id="webelement元素"><code>WebElement</code>元素：</h4>
<p><code>from selenium.webdriver.remote.webelement import WebElement</code>类是每个获取出来的元素的所属类。<br>
有一些常用的属性：</p>
<ol>
<li>get_attribute：这个标签的某个属性的值。</li>
<li>screentshot：获取当前页面的截图。这个方法只能在<code>driver</code>上使用。<br>
<code>driver</code>的对象类，也是继承自<code>WebElement</code>。<br>
更多请阅读相关源代码。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[12-多线程爬虫]]></title>
        <id>https://hehelv.github.io//post/1-duo-xian-cheng-pa-chong</id>
        <link href="https://hehelv.github.io//post/1-duo-xian-cheng-pa-chong">
        </link>
        <updated>2020-03-03T03:13:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="12-多线程爬虫">12-多线程爬虫</h1>
<p>有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用之前那种同步的方式下载。那效率肯会特别慢。这时候我们就可以考虑使用多线程的方式来下载图片。</p>
<h2 id="多线程介绍">多线程介绍：</h2>
<p>多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。<br>
最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也可以有多节车厢。多线程的出现就是为了提高效率。同时它的出现也带来了一些问题。更多介绍请参考：https://baike.baidu.com/item/多线程/1190404?fr=aladdin</p>
<h2 id="threading模块介绍">threading模块介绍：</h2>
<p><code>threading</code>模块是<code>python</code>中专门提供用来做多线程编程的模块。<code>threading</code>模块中最常用的类是<code>Thread</code>。以下看一个简单的多线程程序：</p>
<pre><code class="language-python">import threading
import time

def coding():
    for x in range(3):
        print('%s正在写代码' % x)
        time.sleep(1)

def drawing():
    for x in range(3):
        print('%s正在画图' % x)
        time.sleep(1)


def single_thread():
    coding()
    drawing()

def multi_thread():
    t1 = threading.Thread(target=coding)
    t2 = threading.Thread(target=drawing)

    t1.start()
    t2.start()

if __name__ == '__main__':
    multi_thread()
</code></pre>
<h3 id="查看线程数">查看线程数：</h3>
<p>使用<code>threading.enumerate()</code>函数便可以看到当前线程的数量。</p>
<h3 id="查看当前线程的名字">查看当前线程的名字：</h3>
<p>使用<code>threading.current_thread()</code>可以看到当前线程的信息。</p>
<h3 id="继承自threadingthread类">继承自<code>threading.Thread</code>类：</h3>
<p>为了让线程代码更好的封装。可以使用<code>threading</code>模块下的<code>Thread</code>类，继承自这个类，然后实现<code>run</code>方法，线程就会自动运行<code>run</code>方法中的代码。示例代码如下：</p>
<pre><code class="language-python">import threading
import time

class CodingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print('%s正在写代码' % threading.current_thread())
            time.sleep(1)

class DrawingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print('%s正在画图' % threading.current_thread())
            time.sleep(1)

def multi_thread():
    t1 = CodingThread()
    t2 = DrawingThread()

    t1.start()
    t2.start()

if __name__ == '__main__':
    multi_thread()
</code></pre>
<h3 id="多线程共享全局变量的问题">多线程共享全局变量的问题：</h3>
<p>多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。比如以下代码：</p>
<pre><code class="language-python">import threading

tickets = 0

def get_ticket():
    global tickets
    for x in range(1000000):
        tickets += 1
    print('tickets:%d'%tickets)

def main():
    for x in range(2):
        t = threading.Thread(target=get_ticket)
        t.start()

if __name__ == '__main__':
    main()
</code></pre>
<p>以上结果正常来讲应该是6，但是因为多线程运行的不确定性。因此最后的结果可能是随机的。</p>
<h3 id="锁机制">锁机制：</h3>
<p>为了解决以上使用共享全局变量的问题。<code>threading</code>提供了一个<code>Lock</code>类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，直到当前线程处理完后，把锁释放了，其他线程才能进来处理。示例代码如下：</p>
<pre><code class="language-python">import threading

VALUE = 0

gLock = threading.Lock()

def add_value():
    global VALUE
    gLock.acquire()
    for x in range(1000000):
        VALUE += 1
    gLock.release()
    print('value：%d'%VALUE)

def main():
    for x in range(2):
        t = threading.Thread(target=add_value)
        t.start()

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="lock版本生产者和消费者模式">Lock版本生产者和消费者模式：</h2>
<p>生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。以下是使用<code>threading.Lock</code>锁实现的“生产者与消费者模式”的一个例子：</p>
<pre><code class="language-python">import threading
import random
import time

gMoney = 1000
gLock = threading.Lock()
# 记录生产者生产的次数，达到10次就不再生产
gTimes = 0

class Producer(threading.Thread):
    def run(self):
        global gMoney
        global gLock
        global gTimes
        while True:
            money = random.randint(100, 1000)
            gLock.acquire()
            # 如果已经达到10次了，就不再生产了
            if gTimes &gt;= 10:
                gLock.release()
                break
            gMoney += money
            print('%s当前存入%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
            gTimes += 1
            time.sleep(0.5)
            gLock.release()

class Consumer(threading.Thread):
    def run(self):
        global gMoney
        global gLock
        global gTimes
        while True:
            money = random.randint(100, 500)
            gLock.acquire()
            if gMoney &gt; money:
                gMoney -= money
                print('%s当前取出%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
                time.sleep(0.5)
            else:
                # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下
                if gTimes &gt;= 10:
                    gLock.release()
                    break
                print(&quot;%s当前想取%s元钱，剩余%s元钱，不足！&quot; % (threading.current_thread(),money,gMoney))
            gLock.release()

def main():
    for x in range(5):
        Consumer(name='消费者线程%d'%x).start()

    for x in range(5):
        Producer(name='生产者线程%d'%x).start()

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="condition版的生产者与消费者模式">Condition版的生产者与消费者模式：</h2>
<p><code>Lock</code>版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过<code>while True</code>死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用<code>threading.Condition</code>来实现。<code>threading.Condition</code>可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用<code>notify</code>相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。首先对<code>threading.Condition</code>相关的函数做个介绍，<code>threading.Condition</code>类似<code>threading.Lock</code>，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下将一些常用的函数做个简单的介绍：</p>
<ol>
<li><code>acquire</code>：上锁。</li>
<li><code>release</code>：解锁。</li>
<li><code>wait</code>：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用<code>notify</code>和<code>notify_all</code>函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。</li>
<li><code>notify</code>：通知某个正在等待的线程，默认是第1个等待的线程。</li>
<li><code>notify_all</code>：通知所有正在等待的线程。<code>notify</code>和<code>notify_all</code>不会释放锁。并且需要在<code>release</code>之前调用。</li>
</ol>
<p><code>Condition</code>版的生产者与消费者模式代码如下：</p>
<pre><code class="language-python">import threading
import random
import time

gMoney = 1000
gCondition = threading.Condition()
gTimes = 0
gTotalTimes = 5

class Producer(threading.Thread):
    def run(self):
        global gMoney
        global gCondition
        global gTimes
        while True:
            money = random.randint(100, 1000)
            gCondition.acquire()
            if gTimes &gt;= gTotalTimes:
                gCondition.release()
                print('当前生产者总共生产了%s次'%gTimes)
                break
            gMoney += money
            print('%s当前存入%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
            gTimes += 1
            time.sleep(0.5)
            gCondition.notify_all()
            gCondition.release()

class Consumer(threading.Thread):
    def run(self):
        global gMoney
        global gCondition
        while True:
            money = random.randint(100, 500)
            gCondition.acquire()
            # 这里要给个while循环判断，因为等轮到这个线程的时候
            # 条件有可能又不满足了
            while gMoney &lt; money:
                if gTimes &gt;= gTotalTimes:
                    gCondition.release()
                    return
                print('%s准备取%s元钱，剩余%s元钱，不足！'%(threading.current_thread(),money,gMoney))
                gCondition.wait()
            gMoney -= money
            print('%s当前取出%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
            time.sleep(0.5)
            gCondition.release()

def main():
    for x in range(5):
        Consumer(name='消费者线程%d'%x).start()

    for x in range(2):
        Producer(name='生产者线程%d'%x).start()

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="queue线程安全队列">Queue线程安全队列：</h2>
<p>在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做<code>queue</code>模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下：</p>
<ol>
<li>初始化Queue(maxsize)：创建一个先进先出的队列。</li>
<li>qsize()：返回队列的大小。</li>
<li>empty()：判断队列是否为空。</li>
<li>full()：判断队列是否满了。</li>
<li>get()：从队列中取最后一个数据。</li>
<li>put()：将一个数据放到队列中。</li>
</ol>
<h2 id="使用生产者与消费者模式多线程下载表情包">使用生产者与消费者模式多线程下载表情包：</h2>
<pre><code class="language-python">import threading
import requests
from lxml import etree
from urllib import request
import os
import re
from queue import Queue

class Producer(threading.Thread):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
    }
    def __init__(self,page_queue,img_queue,*args,**kwargs):
        super(Producer, self).__init__(*args,**kwargs)
        self.page_queue = page_queue
        self.img_queue = img_queue


    def run(self):
        while True:
            if self.page_queue.empty():
                break
            url = self.page_queue.get()
            self.parse_page(url)

    def parse_page(self,url):
        response = requests.get(url,headers=self.headers)
        text = response.text
        html = etree.HTML(text)
        imgs = html.xpath(&quot;//div[@class='page-content text-center']//a//img&quot;)
        for img in imgs:
            if img.get('class') == 'gif':
                continue
            img_url = img.xpath(&quot;.//@data-original&quot;)[0]
            suffix = os.path.splitext(img_url)[1]
            alt = img.xpath(&quot;.//@alt&quot;)[0]
            alt = re.sub(r'[，。？?,/\\·]','',alt)
            img_name = alt + suffix
            self.img_queue.put((img_url,img_name))

class Consumer(threading.Thread):
    def __init__(self,page_queue,img_queue,*args,**kwargs):
        super(Consumer, self).__init__(*args,**kwargs)
        self.page_queue = page_queue
        self.img_queue = img_queue

    def run(self):
        while True:
            if self.img_queue.empty():
                if self.page_queue.empty():
                    return
            img = self.img_queue.get(block=True)
            url,filename = img
            request.urlretrieve(url,'images/'+filename)
            print(filename+'  下载完成！')

def main():
    page_queue = Queue(100)
    img_queue = Queue(500)
    for x in range(1,101):
        url = &quot;http://www.doutula.com/photo/list/?page=%d&quot; % x
        page_queue.put(url)

    for x in range(5):
        t = Producer(page_queue,img_queue)
        t.start()

    for x in range(5):
        t = Consumer(page_queue,img_queue)
        t.start()

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="gil全局解释器锁">GIL全局解释器锁：</h2>
<p>Python自带的解释器是<code>CPython</code>。<code>CPython</code>解释器的多线程实际上是一个假的多线程（在多核CPU中，只能利用一核，不能利用多核）。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在<code>CPython</code>解释器中有一个东西叫做<code>GIL（Global Intepreter Lock）</code>，叫做全局解释器锁。这个解释器锁是有必要的。因为<code>CPython</code>解释器的内存管理不是线程安全的。当然除了<code>CPython</code>解释器，还有其他的解释器，有些解释器是没有<code>GIL</code>锁的，见下面：</p>
<ol>
<li><code>Jython</code>：用Java实现的Python解释器。不存在GIL锁。更多详情请见：https://zh.wikipedia.org/wiki/Jython</li>
<li><code>IronPython</code>：用<code>.net</code>实现的Python解释器。不存在GIL锁。更多详情请见：https://zh.wikipedia.org/wiki/IronPython</li>
<li><code>PyPy</code>：用<code>Python</code>实现的Python解释器。存在GIL锁。更多详情请见：https://zh.wikipedia.org/wiki/PyPy<br>
GIL虽然是一个假的多线程。但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。</li>
</ol>
<h2 id="多线程下载百思不得姐段子作业">多线程下载百思不得姐段子作业：</h2>
<pre><code class="language-python">import requests
from lxml import etree
import threading
from queue import Queue
import csv


class BSSpider(threading.Thread):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
    }
    def __init__(self,page_queue,joke_queue,*args,**kwargs):
        super(BSSpider, self).__init__(*args,**kwargs)
        self.base_domain = 'http://www.budejie.com'
        self.page_queue = page_queue
        self.joke_queue = joke_queue

    def run(self):
        while True:
            if self.page_queue.empty():
                break
            url = self.page_queue.get()
            response = requests.get(url, headers=self.headers)
            text = response.text
            html = etree.HTML(text)
            descs = html.xpath(&quot;//div[@class='j-r-list-c-desc']&quot;)
            for desc in descs:
                jokes = desc.xpath(&quot;.//text()&quot;)
                joke = &quot;\n&quot;.join(jokes).strip()
                link = self.base_domain+desc.xpath(&quot;.//a/@href&quot;)[0]
                self.joke_queue.put((joke,link))
            print('='*30+&quot;第%s页下载完成！&quot;%url.split('/')[-1]+&quot;=&quot;*30)

class BSWriter(threading.Thread):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
    }

    def __init__(self, joke_queue, writer,gLock, *args, **kwargs):
        super(BSWriter, self).__init__(*args, **kwargs)
        self.joke_queue = joke_queue
        self.writer = writer
        self.lock = gLock

    def run(self):
        while True:
            try:
                joke_info = self.joke_queue.get(timeout=40)
                joke,link = joke_info
                self.lock.acquire()
                self.writer.writerow((joke,link))
                self.lock.release()
                print('保存一条')
            except:
                break

def main():
    page_queue = Queue(10)
    joke_queue = Queue(500)
    gLock = threading.Lock()
    fp = open('bsbdj.csv', 'a',newline='', encoding='utf-8')
    writer = csv.writer(fp)
    writer.writerow(('content', 'link'))

    for x in range(1,11):
        url = 'http://www.budejie.com/text/%d' % x
        page_queue.put(url)

    for x in range(5):
        t = BSSpider(page_queue,joke_queue)
        t.start()

    for x in range(5):
        t = BSWriter(joke_queue,writer,gLock)
        t.start()

if __name__ == '__main__':
    main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[11-MongoDB数据库]]></title>
        <id>https://hehelv.github.io//post/11-mongodb-shu-ju-ku</id>
        <link href="https://hehelv.github.io//post/11-mongodb-shu-ju-ku">
        </link>
        <updated>2020-03-02T05:29:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="11-mongodb数据库">11-MongoDB数据库</h1>
<h2 id="介绍">介绍</h2>
<p>官方文档：http://www.mongoing.com/docs/</p>
<h3 id="文档">文档</h3>
<p>MongoDB是一个面向文档的数据库<br>
举例：{“foo”:3, “greeting”:“Hello,world!”}<br>
区分大小写，且key唯一，不可重复，文档可嵌套</p>
<h3 id="集合">集合</h3>
<p>集合就是一组文档<br>
文档类似于关系型数据库里的行<br>
集合类似于关系型数据库里的表<br>
集合中的文档无需固定额结构（与关系型数据库的区别）</p>
<h3 id="集合的命名">集合的命名</h3>
<ol>
<li>不能有空字符串（&quot; &quot;）</li>
<li>不能包含\0字符（空字符）</li>
<li>不能使用system.的前缀（系统保留）</li>
<li>建议不包含保留字 &quot;$&quot;</li>
<li>用 .  分割不懂命名空间的子集合（如：blog.users， blog.posts）</li>
</ol>
<h3 id="数据库">数据库</h3>
<ol>
<li>多个文档组成集合，多个集合组成数据库</li>
<li>一个实例可以承载多个数据库</li>
<li>每个数据库都有独立的权限</li>
<li>保留的数据名称（admin,local,config）</li>
</ol>
<h2 id="mongodb安装启动">MongoDB安装启动</h2>
<p>下载mis包，安装在根目录下MongoDB文件夹里就OK，例如：D：\MongDB......。切记一开始安装不要选择附带安装compass图形工具，这个下载很慢可能直接卡死。</p>
<p>启动：<br>
配置数据路径<br>
在目录D:\MongoDB\Server\4.0的bin文件使用'Shift'+'右键'选择在此处打开cmd，然后再cmd中输入：monogod --dbpath D:\MongoDB\Server\4.0\data<br>
回车，来到NETWORK  [thread1] waiting for connections on port 27017<br>
此时，在bin里打开另一个cmd，输入mongo，回车，就OK啦<br>
可以使用 show databases 试一试</p>
<h3 id="使用命令行操作数据库crud">使用命令行操作数据库（CRUD）</h3>
<p>新增数据（Create）</p>
<pre><code class="language-bash"># 进入数据库，如果没有该数据库，会自动创建
use students； 
# 新增数据
stu = {
  name:'Jhon',
  age:21}
# 插入数据到数据库
db.students.insert(stu)
</code></pre>
<p>查询数据（Read）</p>
<pre><code class="language-css"># 查询students中的所有数据
db.students.find()
# 查询students中的一条数据
db.students.findOne()
</code></pre>
<p>修改数据（Update）</p>
<pre><code class="language-bash"># 需要先查询这条数据
s = db.students.findOne()
# 修改数据=替换数据，替换后的数据没有年龄
db.students.update({name: 'Jhon'}, {name: 'JhonC'})
</code></pre>
<p>删除数据（Delete）</p>
<pre><code class="language-css"># 删除该属性的数据
db.students.remove({name: 'JhonC'})
# 删除students中的所有数据
db.students.remove(())
</code></pre>
<p>练习：</p>
<pre><code class="language-csharp"># 新建并进入数据库
use students
# 查看当前数据库
db.log
#插入多条数据
db.students.insertMany(
    [
        { name:&quot;bob&quot;, age:16, sex: &quot;male&quot;, grade:95},
        { name:&quot;ahn&quot;, age:18, sex: &quot;female&quot;, grade:45},
        { name:&quot;xi&quot;, age:15, sex: &quot;male&quot;, grade:75},
        { name:&quot;bob1&quot;, age:16, sex: &quot;male&quot;, grade:95},
        { name:&quot;ahn1&quot;, age:18, sex: &quot;male&quot;, grade:45},
        { name:&quot;xi1&quot;, age:15, sex: &quot;female&quot;, grade:55},
        { name:&quot;bob2&quot;, age:16, sex: &quot;female&quot;, grade:95},
        { name:&quot;ahn2&quot;, age:18, sex: &quot;male&quot;, grade:60},
        { name:&quot;xi2&quot;, age:15, sex: &quot;male&quot;, grade:75},
        { name:&quot;bob3&quot;, age:16, sex: &quot;male&quot;, grade:95},
        { name:&quot;ahn3&quot;, age:18, sex: &quot;female&quot;, grade:45},
        { name:&quot;xi3&quot;, age:15, sex: &quot;male&quot;, grade:85},
        { name:&quot;bob4&quot;, age:16, sex: &quot;female&quot;, grade:95},
        { name:&quot;ahn4&quot;, age:18, sex: &quot;male&quot;, grade:45},
        { name:&quot;xi4&quot;, age:15, sex: &quot;male&quot;, grade:75}
    ]
)
# 查看所有数据
db.students.find()
# 查看数据数量
db.students.count()
# cls 清屏
# 查询所有男生数据
db.students.find({sex: 'male'})
# 查询所有及格学生信息
db.students.find({grade:{'$gte':60}})
# 查询所有18岁男生和16岁女生的数据
db.students.find({'$or':[{sex:'male', age:18}, {sex: 'female', age:16}]})
# 按照学生的年龄进行排序（1代表升序，-1代表降序）
db.students.find().sort({age: 1})
# 给所有学生都加一个地址=china的字段属性（修改器操作）
db.students.update({}, {'$set':{adress:'china'}}, {multi:true})
# 给所有女学生都加一岁（修改器操作）
db.students.update({sex:'female'}, {'$inc':{age:1}}, {multi: true})
</code></pre>
<h2 id="使用python连接mongodb">使用Python连接MongoDB</h2>
<p>手动启动MongoDB<br>
在MongoDB的bin目录打开cmd 输入 monogod --dbpath D:\MongoDB\Server\4.0\data</p>
<pre><code class="language-python"># 建立客户端连接的三种方法
from pymongo import MongoClient
client = MongoClient()
# client2 = MongoClient('localhost', 27017)
# client3 = MongoClient('mongodb://localhost:27017')
# 显示数据库
dbs = client.list_database_names()
print(dbs)
# 进入某个数据库
db = client.blog
</code></pre>
<h3 id="curd完整示例代码">curd完整示例代码</h3>
<pre><code class="language-python">from pymongo import MongoClient
from bson.objectid import ObjectId


class TestMongo(object):

    def __init__(self):
        self.client = MongoClient()
        self.db = self.client['students']

    def add_one(self):
        '''新增数据'''
        post ={
            'name': 'ben',
            'age': 18,
            'sex': &quot;male&quot;,
            'grade': 80,
            'adress': &quot;china&quot;
        }
        return self.db.students.insert_one(post)
    def add_many(self):
        '''新增多条数据'''
        infos = [
            {'name': 'ben', 'age': 18, 'sex': &quot;male&quot;, 'grade': 80, 'adress': &quot;china&quot;},
            {'name': 'sum', 'age': 19, 'sex': &quot;male&quot;, 'grade': 75, 'adress': &quot;china&quot;},
            {'name': 'lily', 'age': 16, 'sex': &quot;female&quot;, 'grade': 90, 'adress': &quot;china&quot;},
            {'name': 'teddy', 'age': 19, 'sex': &quot;male&quot;, 'grade': 65, 'adress': &quot;china&quot;},
            {'name': 'fluence', 'age': 18, 'sex': &quot;female&quot;, 'grade': 80, 'adress': &quot;china&quot;}
            ]
        return self.db.students.insert_many(infos)

    def get_one(self):
        '''查询一条数据'''
        return self.db.students.find_one()

    def get_more(self):
        '''查询多条数据'''
        return self.db.students.find({'age': 18})

    def get_one_from_oid(self, oid):
        '''查询指定ID的数据'''
        obj = ObjectId(oid)
        return self.db.students.find_one({'_id': obj})

    def update_one(self):
        '''修改一条数据'''
        return self.db.students.update_one({'age': 20}, {'$inc': {'x': 10}})

    def update_many(self):
        '''修改多条数据'''
        return self.db.students.update_many({}, {'$inc': {'age': 5}})

    def dalete_one(self):
        '''删除一条数据'''
        return self.db.students.delete_one({'name': 'ben'})

    def delete_many(self):
        '''删除多条数据'''
        return self.db.students.delete_many({'age': 24})

def main():
    obj = TestMongo()
    # rest = obj.add_one()
    # print(rest)

    # rest = obj.add_many()
    # print(rest)

    # rest = obj.get_one()
    # print(rest)

    # rest = obj.get_more()
    # for i in rest:
    #     print(i['_id'])

    # rest = obj.get_one_from_oid('5c68b5cb5a49891b40b8a18e')
    # print(rest)

    # rest = obj.update_one()
    # print(rest)

    # rest = obj.update_many()
    # print(rest)

    # rest = obj.delete_one()
    # print(rest.delete_count)

    # rest = obj.delete_many()
    # print(rest.delete_count)
if __name__ == '__main__':
    main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10-MySQL数据库]]></title>
        <id>https://hehelv.github.io//post/10-mysql-shu-ju-ku</id>
        <link href="https://hehelv.github.io//post/10-mysql-shu-ju-ku">
        </link>
        <updated>2020-03-02T05:28:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="10-mysql数据库">10-MySQL数据库</h1>
<h2 id="安装mysql">安装mysql：</h2>
<ol>
<li>在官网：https://dev.mysql.com/downloads/windows/installer/5.7.html</li>
<li>如果提示没有<code>.NET Framework</code>框架。那么就在提示框中找到下载链接，下载一个就可以了。</li>
<li>如果提示没有<code>Microsoft Virtual C++ x64(x86)</code>，那么百度或者谷歌这个软件安装即可。</li>
<li>如果没有找到。那么私聊我。</li>
</ol>
<h2 id="navicat">navicat：</h2>
<p>navicat是一个操作mysql数据库非常方便的软件。使用他操作数据库，就跟使用excel操作数据是一样的。</p>
<h2 id="安装驱动程序">安装驱动程序：</h2>
<p>Python要想操作MySQL。必须要有一个中间件，或者叫做驱动程序。驱动程序有很多。比如有<code>mysqldb</code>、<code>mysqlclient</code>、<code>pymysql</code>等。在这里，我们选择用<code>pymysql</code>。安装方式也是非常简单，通过命令<code>pip install pymysql</code>即可安装。</p>
<h2 id="数据库连接">数据库连接：</h2>
<p>数据库连接之前。首先先确认以下工作完成，这里我们以一个<code>pymysql_test</code>数据库.以下将介绍连接<code>mysql</code>的示例代码：</p>
<pre><code class="language-python">    import pymysql

    db = pymysql.connect(
        host=&quot;127.0.0.1&quot;,
        user='root',
        password='root',
        database='pymysql_test',
        port=3306
    )
    cursor = db.cursor()
    cursor.execute(&quot;select 1&quot;)
    data = cursor.fetchone()
    print(data)
    db.close()
</code></pre>
<h2 id="插入数据">插入数据：</h2>
<pre><code class="language-python">import pymysql

db = pymysql.connect(
    host=&quot;127.0.0.1&quot;,
    user='root',
    password='root',
    database='pymysql_test',
    port=3306
)
cursor = db.cursor()
sql = &quot;&quot;&quot;
insert into user(
    id,username,gender,age,password
  ) 
  values(null,'abc',1,18,'111111');
&quot;&quot;&quot;
cursor.execute(sql)
db.commit()
db.close()
</code></pre>
<p>如果在数据还不能保证的情况下，可以使用以下方式来插入数据：</p>
<pre><code class="language-python">sql = &quot;&quot;&quot;
insert into user(
    id,username,gender,age,password
  ) 
  values(null,%s,%s,%s,%s);
&quot;&quot;&quot;

cursor.execute(sql,('spider',1,20,'222222'))
</code></pre>
<h2 id="查找数据">查找数据：</h2>
<p>使用<code>pymysql</code>查询数据。可以使用<code>fetch*</code>方法。</p>
<ol>
<li><code>fetchone()</code>：这个方法每次之获取一条数据。</li>
<li><code>fetchall()</code>：这个方法接收全部的返回结果。</li>
<li><code>fetchmany(size)</code>：可以获取指定条数的数据。<br>
示例代码如下：</li>
</ol>
<pre><code class="language-python">cursor = db.cursor()

sql = &quot;&quot;&quot;
select * from user
&quot;&quot;&quot;

cursor.execute(sql)
while True:
    result = cursor.fetchone()
    if not result:
        break
    print(result)
db.close()
</code></pre>
<p>或者是直接使用<code>fetchall</code>，一次性可以把所有满足条件的数据都取出来：</p>
<pre><code class="language-python">cursor = db.cursor()

sql = &quot;&quot;&quot;
select * from user
&quot;&quot;&quot;

cursor.execute(sql)
results = cursor.fetchall()
for result in results:
    print(result)
db.close()
</code></pre>
<p>或者是使用<code>fetchmany</code>，指定获取多少条数据：</p>
<pre><code class="language-python">cursor = db.cursor()

sql = &quot;&quot;&quot;
select * from user
&quot;&quot;&quot;

cursor.execute(sql)
results = cursor.fetchmany(1)
for result in results:
    print(result)
db.close()
</code></pre>
<h2 id="删除数据">删除数据：</h2>
<pre><code class="language-python">cursor = db.cursor()

sql = &quot;&quot;&quot;
delete from user where id=1
&quot;&quot;&quot;

cursor.execute(sql)
db.commit()
db.close()
</code></pre>
<h2 id="更新数据">更新数据：</h2>
<pre><code class="language-python">conn = pymysql.connect(host='localhost',user='root',password='root',database='pymysql_demo',port=3306)
cursor = conn.cursor()

sql = &quot;&quot;&quot;
update user set username='aaa' where id=1
&quot;&quot;&quot;
cursor.execute(sql)
conn.commit()

conn.close()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[9-excel文件处理]]></title>
        <id>https://hehelv.github.io//post/9-excel-wen-jian-chu-li</id>
        <link href="https://hehelv.github.io//post/9-excel-wen-jian-chu-li">
        </link>
        <updated>2020-03-02T05:26:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="9-excel文件处理">9-excel文件处理</h1>
<h2 id="安装环境">安装环境</h2>
<ol>
<li>
<p>pandas依赖处理Excel的xlrd模块，所以我们需要提前安装这个，安装命令是：pip install xlrd</p>
</li>
<li>
<p>安装pandas模块还需要一定的编码环境，所以我们自己在安装的时候，确保你的电脑有这些环境：Net.4 、VC-Compiler以及winsdk_web，如果大家没有这些软件~可以咨询我们的辅导员索要相关安装工具。</p>
</li>
<li>
<p>步骤1和2 准备好了之后，我们就可以开始安装pandas了，安装命令是：pip install pandas</p>
</li>
</ol>
<h2 id="pandas操作excel表单">pandas操作Excel表单</h2>
<p>数据准备，有一个Excel文件：lemon.xlsx有两个表单，表单名分别为：Python 以及student，</p>
<p>Python的表单数据如下所示：</p>
<figure data-type="image" tabindex="1"><img src="../images/pandas-01.png" alt=""></figure>
<p>student的表单数据如下所示：</p>
<figure data-type="image" tabindex="2"><img src="../images/pandas-02.png" alt=""></figure>
<p>1：在利用pandas模块进行操作前，可以先引入这个模块，如下：</p>
<pre><code>import  pandas  as pd
</code></pre>
<p>2:读取Excel文件的两种方式：</p>
<pre><code class="language-sheel">#方法一：默认读取第一个表单df=pd.read_excel('lemon.xlsx')#这个会直接默认读取到这个Excel的第一个表单
data=df.head()#默认读取前5行的数据
print(&quot;获取到所有的值:\n{0}&quot;.format(data))#格式化输出
</code></pre>
<p>得到的结果是一个二维矩阵，如下所示：</p>
<figure data-type="image" tabindex="3"><img src="../images/pandas-03.png" alt=""></figure>
<pre><code class="language-sheel">#方法二：通过指定表单名的方式来读取
df=pd.read_excel('lemon.xlsx',sheet_name='student')#可以通过sheet_name来指定读取的表单
data=df.head()#默认读取前5行的数据
print(&quot;获取到所有的值:\n{0}&quot;.format(data))#格式化输出
</code></pre>
<p>得到的结果如下所示，也是一个二维矩阵：<br>
<img src="../images/pandas-04.png" alt=""></p>
<pre><code class="language-shell">#方法三：通过表单索引来指定要访问的表单，0表示第一个表单
#也可以采用表单名和索引的双重方式来定位表单
#也可以同时定位多个表单，方式都罗列如下所示
df=pd.read_excel('lemon.xlsx',sheet_name=['python','student'])#可以通过表单名同时指定多个
# df=pd.read_excel('lemon.xlsx',sheet_name=0)#可以通过表单索引来指定读取的表单
# df=pd.read_excel('lemon.xlsx',sheet_name=['python',1])#可以混合的方式来指定
# df=pd.read_excel('lemon.xlsx',sheet_name=[1,2])#可以通过索引 同时指定多个
data=df.values#获取所有的数据，注意这里不能用head()方法哦~
print(&quot;获取到所有的值:\n{0}&quot;.format(data))#格式化输出
</code></pre>
<h2 id="pandas操作excel的行列">pandas操作Excel的行列</h2>
<p><strong>1：读取指定的单行，数据会存在列表里面</strong></p>
<pre><code>#1：读取指定行df=pd.read_excel('lemon.xlsx')#这个会直接默认读取到这个Excel的第一个表单
data=df.ix[0].values#0表示第一行 这里读取数据并不包含表头，要注意哦！
print(&quot;读取指定行的数据：\n{0}&quot;.format(data))
</code></pre>
<p>得到的结果如下所示:</p>
<figure data-type="image" tabindex="4"><img src="../images/pandas-05.png" alt=""></figure>
<p><strong>2：读取指定的多行，数据会存在嵌套的列表里面：</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
data=df.ix[[1,2]].values#读取指定多行的话，就要在ix[]里面嵌套列表指定行数
print(&quot;读取指定行的数据：\n{0}&quot;.format(data))
</code></pre>
<p><strong>3：读取指定的行列：</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
data=df.ix[1,2]#读取第一行第二列的值，这里不需要嵌套列表
print(&quot;读取指定行的数据：\n{0}&quot;.format(data))
</code></pre>
<p><strong>4：读取指定的多行多列值：</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
data=df.ix[[1,2],['title','data']].values#读取第一行第二行的title以及data列的值，这里需要嵌套列表
print(&quot;读取指定行的数据：\n{0}&quot;.format(data))
</code></pre>
<p><strong>5：获取所有行的指定列</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
data=df.ix[:,['title','data']].values#读所有行的title以及data列的值，这里需要嵌套列表
print(&quot;读取指定行的数据：\n{0}&quot;.format(data))
</code></pre>
<p><strong>6：获取行号并打印输出</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
print(&quot;输出行号列表&quot;,df.index.values)

输出结果是：
输出行号列表 [0 1 2 3]
</code></pre>
<p><strong>7：获取列名并打印输出</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
print(&quot;输出列标题&quot;,df.columns.values)

运行结果如下所示：
输出列标题 ['case_id' 'title' 'data']
</code></pre>
<p><strong>8：获取指定行数的值：</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
print(&quot;输出值&quot;,df.sample(3).values)#这个方法类似于head()方法以及df.values方法

输出值
 [[2 '输入错误的密码' '{&quot;mobilephone&quot;:&quot;18688773467&quot;,&quot;pwd&quot;:&quot;12345678&quot;}']
 [3 '正常充值' '{&quot;mobilephone&quot;:&quot;18688773467&quot;,&quot;amount&quot;:&quot;1000&quot;}']
 [1 '正常登录' '{&quot;mobilephone&quot;:&quot;18688773467&quot;,&quot;pwd&quot;:&quot;123456&quot;}']]
</code></pre>
<p><strong>9：获取指定列的值：</strong></p>
<pre><code>df=pd.read_excel('lemon.xlsx')
print(&quot;输出值\n&quot;,df['data'].values)
</code></pre>
<h2 id="pandas处理excel数据成为字典">pandas处理Excel数据成为字典</h2>
<p>有如下的数据，处理成列表嵌套字典，且字典的key为表头名。</p>
<h2 id=""><img src="../images/pandas-06.png" alt=""></h2>
<p>实现的代码如下所示：</p>
<pre><code>df=pd.read_excel('lemon.xlsx')
test_data=[]
for i in df.index.values:#获取行号的索引，并对其进行遍历：
    #根据i来获取每一行指定的数据 并利用to_dict转成字典
    row_data=df.ix[i,['case_id','module','title','http_method','url','data','expected']].to_dict()
    test_data.append(row_data)
print(&quot;最终获取到的数据是：{0}&quot;.format(test_data))
</code></pre>
<p>最后得到的结果是：</p>
<pre><code>最终获取到的数据是：
[{'title': '正常登录', 'case_id': 1, 'data': '{&quot;mobilephone&quot;:&quot;18688773467&quot;,&quot;pwd&quot;:&quot;123456&quot;}'}, 
{'title': '输入错误的密码', 'case_id': 2, 'data': '{&quot;mobilephone&quot;:&quot;18688773467&quot;,&quot;pwd&quot;:&quot;12345678&quot;}'}, 
{'title': '正常充值', 'case_id': 3, 'data': '{&quot;mobilephone&quot;:&quot;18688773467&quot;,&quot;amount&quot;:&quot;1000&quot;}'}, 
{'title': '充值输入负数', 'case_id': 4, 'data': '{&quot;mobilephone&quot;:&quot;18688773467&quot;,&quot;amount&quot;:&quot;-100&quot;}'}]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8-csv文件处理]]></title>
        <id>https://hehelv.github.io//post/8-csv-wen-jian-chu-li</id>
        <link href="https://hehelv.github.io//post/8-csv-wen-jian-chu-li">
        </link>
        <updated>2020-03-02T03:07:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="8-csv文件处理">8-csv文件处理</h1>
<h2 id="读取csv文件">读取csv文件：</h2>
<pre><code class="language-python">import csv

with open('stock.csv','r') as fp:
    reader = csv.reader(fp)
    titles = next(reader)
    for x in reader:
        print(x)
</code></pre>
<p>这样操作，以后获取数据的时候，就要通过下表来获取数据。如果想要在获取数据的时候通过标题来获取。那么可以使用<code>DictReader</code>。示例代码如下：</p>
<pre><code class="language-python">import csv

with open('stock.csv','r') as fp:
    reader = csv.DictReader(fp)
    for x in reader:
        print(x['turnoverVol'])
</code></pre>
<h2 id="写入数据到csv文件">写入数据到csv文件：</h2>
<p>写入数据到csv文件，需要创建一个<code>writer</code>对象，主要用到两个方法。一个是<code>writerow</code>，这个是写入一行。一个是<code>writerows</code>，这个是写入多行。示例代码如下：</p>
<pre><code class="language-python">import csv

headers = ['name','age','classroom']
values = [
    ('zhiliao',18,'111'),
    ('wena',20,'222'),
    ('bbc',21,'111')
]
with open('test.csv','w',newline='') as fp:
    writer = csv.writer(fp)
    writer.writerow(headers)
    writer.writerows(values)
</code></pre>
<p>也可以使用字典的方式把数据写入进去。这时候就需要使用<code>DictWriter</code>了。示例代码如下：</p>
<pre><code class="language-python">import csv

headers = ['name','age','classroom']
values = [
    {&quot;name&quot;:'wenn',&quot;age&quot;:20,&quot;classroom&quot;:'222'},
    {&quot;name&quot;:'abc',&quot;age&quot;:30,&quot;classroom&quot;:'333'}
]
with open('test.csv','w',newline='') as fp:
    writer = csv.DictWriter(fp,headers)
    writer = csv.writeheader()
    writer.writerow({'name':'zhiliao',&quot;age&quot;:18,&quot;classroom&quot;:'111'})
    writer.writerows(values
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7-json文件处理]]></title>
        <id>https://hehelv.github.io//post/7-json-wen-jian-chu-li</id>
        <link href="https://hehelv.github.io//post/7-json-wen-jian-chu-li">
        </link>
        <updated>2020-02-28T07:24:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="7-json文件处理">7-json文件处理</h1>
<h2 id="什么是json">什么是json：</h2>
<p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。更多解释请见：https://baike.baidu.com/item/JSON/2462549?fr=aladdin</p>
<h2 id="json支持数据格式">JSON支持数据格式：</h2>
<ol>
<li>对象（字典）。使用花括号。</li>
<li>数组（列表）。使用方括号。</li>
<li>整形、浮点型、布尔类型还有null类型。</li>
<li>字符串类型（字符串必须要用双引号，不能用单引号）。</li>
</ol>
<p>多个数据之间使用逗号分开。<br>
<strong>注意：json本质上就是一个字符串。</strong></p>
<h2 id="字典和列表转json">字典和列表转JSON：</h2>
<pre><code class="language-python">import json

books = [
    {
        'title': '钢铁是怎样练成的',
        'price': 9.8
    },
    {
        'title': '红楼梦',
        'price': 9.9
    }
]

json_str = json.dumps(books,ensure_ascii=False)
print(json_str)
</code></pre>
<p>因为<code>json</code>在<code>dump</code>的时候，只能存放<code>ascii</code>的字符，因此会将中文进行转义，这时候我们可以使用<code>ensure_ascii=False</code>关闭这个特性。<br>
在<code>Python</code>中。只有基本数据类型才能转换成<code>JSON</code>格式的字符串。也即：<code>int</code>、<code>float</code>、<code>str</code>、<code>list</code>、<code>dict</code>、<code>tuple</code>。</p>
<h3 id="将json数据直接dump到文件中">将json数据直接<code>dump</code>到文件中：</h3>
<p><code>json</code>模块中除了<code>dumps</code>函数，还有一个<code>dump</code>函数，这个函数可以传入一个文件指针，直接将字符串<code>dump</code>到文件中。示例代码如下：</p>
<pre><code class="language-python">books = [
    {
        'title': '钢铁是怎样练成的',
        'price': 9.8
    },
    {
        'title': '红楼梦',
        'price': 9.9
    }
]
with open('a.json','w') as fp:
    json.dump(books,fp)
</code></pre>
<h2 id="将一个json字符串load成python对象">将一个json字符串load成Python对象：</h2>
<pre><code class="language-python">json_str = '[{&quot;title&quot;: &quot;钢铁是怎样练成的&quot;, &quot;price&quot;: 9.8}, {&quot;title&quot;: &quot;红楼梦&quot;, &quot;price&quot;: 9.9}]'
books = json.loads(json_str,encoding='utf-8')
print(type(books))
print(books)
</code></pre>
<h3 id="直接从文件中读取json">直接从文件中读取json：</h3>
<pre><code class="language-python">import json
with open('a.json','r',encoding='utf-8') as fp:
    json_str = json.load(fp)
    print(json_str)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[6-正则表达式和re模块]]></title>
        <id>https://hehelv.github.io//post/6-zheng-ze-biao-da-shi-he-re-mo-kuai</id>
        <link href="https://hehelv.github.io//post/6-zheng-ze-biao-da-shi-he-re-mo-kuai">
        </link>
        <updated>2020-02-28T06:37:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="6-正则表达式和re模块">6-正则表达式和re模块</h1>
<h2 id="什么是正则表达式">什么是正则表达式：</h2>
<p>通俗理解：按照一定的规则，从某个字符串中匹配出想要的数据。这个规则就是正则表达式。<br>
标准答案：https://baike.baidu.com/item/正则表达式/1700215?fr=aladdin</p>
<h2 id="一个段子">一个段子：</h2>
<p>世界是分为两种人，一种是懂正则表达式的，一种是不懂正则表达式的。</p>
<h2 id="正则表达式常用匹配规则">正则表达式常用匹配规则：</h2>
<h3 id="匹配某个字符串">匹配某个字符串：</h3>
<pre><code class="language-python">text = 'hello'
ret = re.match('he',text)
print(ret.group())
&gt;&gt; he
</code></pre>
<p>以上便可以在<code>hello</code>中，匹配出<code>he</code>。</p>
<h3 id="点匹配任意的字符">点（.）匹配任意的字符：</h3>
<pre><code class="language-python">text = &quot;ab&quot;
ret = re.match('.',text)
print(ret.group())
&gt;&gt; a
</code></pre>
<p>但是点（.）不能匹配不到换行符。示例代码如下：</p>
<pre><code class="language-python">text = &quot;ab&quot;
ret = re.match('.',text)
print(ret.group())
&gt;&gt; AttributeError: 'NoneType' object has no attribute 'group'
</code></pre>
<h3 id="d匹配任意的数字">\d匹配任意的数字：</h3>
<pre><code class="language-python">text = &quot;123&quot;
ret = re.match('\d',text)
print(ret.group())
&gt;&gt; 1
</code></pre>
<h3 id="d匹配任意的非数字">\D匹配任意的非数字：</h3>
<pre><code class="language-python">text = &quot;a&quot;
ret = re.match('\D',text)
print(ret.group())
&gt;&gt; a
</code></pre>
<p>而如果text是等于一个数字，那么就匹配不成功了。示例代码如下：</p>
<pre><code class="language-python">text = &quot;1&quot;
ret = re.match('\D',text)
print(ret.group())
&gt;&gt; AttributeError: 'NoneType' object has no attribute 'group'
</code></pre>
<h3 id="s匹配的是空白字符包括ntr和空格">\s匹配的是空白字符（包括：\n，\t，\r和空格）：</h3>
<pre><code class="language-python">text = &quot;\t&quot;
ret = re.match('\s',text)
print(ret.group())
&gt;&gt; 空白
</code></pre>
<h3 id="w匹配的是a-z和a-z以及数字和下划线">\w匹配的是<code>a-z</code>和<code>A-Z</code>以及数字和下划线：</h3>
<pre><code class="language-python">text = &quot;_&quot;
ret = re.match('\w',text)
print(ret.group())
&gt;&gt; _
</code></pre>
<p>而如果要匹配一个其他的字符，那么就匹配不到。示例代码如下：</p>
<pre><code class="language-python">text = &quot;+&quot;
ret = re.match('\w',text)
print(ret.group())
&gt;&gt; AttributeError: 'NoneType' object has no attribute
</code></pre>
<h3 id="w匹配的是和w相反的">\W匹配的是和\w相反的：</h3>
<pre><code class="language-python">text = &quot;+&quot;
ret = re.match('\W',text)
print(ret.group())
&gt;&gt; +
</code></pre>
<p>而如果你的text是一个下划线或者英文字符，那么就匹配不到了。示例代码如下：</p>
<pre><code class="language-python">text = &quot;_&quot;
ret = re.match('\W',text)
print(ret.group())
&gt;&gt; AttributeError: 'NoneType' object has no attribute
</code></pre>
<h3 id="组合的方式只要满足中括号中的某一项都算匹配成功">[]组合的方式，只要满足中括号中的某一项都算匹配成功：</h3>
<pre><code class="language-python">text = &quot;0731-88888888&quot;
ret = re.match('[\d\-]+',text)
print(ret.group())
&gt;&gt; 0731-88888888
</code></pre>
<p>之前讲到的几种匹配规则，其实可以使用中括号的形式来进行替代：</p>
<ul>
<li>\d：[0-9]</li>
<li>\D：<a href="#fn_0-9">0-9</a></li>
<li>\w：[0-9a-zA-Z_]</li>
<li>\W：[^0-9a-zA-Z_]</li>
</ul>
<h3 id="匹配多个字符">匹配多个字符：</h3>
<ol>
<li>
<p><code>*</code>：可以匹配0或者任意多个字符。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;0731&quot;
 ret = re.match('\d*',text)
 print(ret.group())
 &gt;&gt; 0731
</code></pre>
<p>以上因为匹配的要求是<code>\d</code>，那么就要求是数字，后面跟了一个星号，就可以匹配到0731这四个字符。</p>
</li>
<li>
<p><code>+</code>：可以匹配1个或者多个字符。最少一个。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;abc&quot;
 ret = re.match('\w+',text)
 print(ret.group())
 &gt;&gt; abc
</code></pre>
<p>因为匹配的是<code>\w</code>，那么就要求是英文字符，后面跟了一个加号，意味着最少要有一个满足<code>\w</code>的字符才能够匹配到。如果text是一个空白字符或者是一个不满足\w的字符，那么就会报错。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;&quot;
 ret = re.match('\w+',text)
 print(ret.group())
 &gt;&gt; AttributeError: 'NoneType' object has no attribute
</code></pre>
</li>
<li>
<p><code>?</code>：匹配的字符可以出现一次或者不出现（0或者1）。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;123&quot;
 ret = re.match('\d?',text)
 print(ret.group())
 &gt;&gt; 1
</code></pre>
</li>
<li>
<p><code>{m}</code>：匹配m个字符。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;123&quot;
 ret = re.match('\d{2}',text)
 print(ret.group())
 &gt;&gt; 12
</code></pre>
</li>
<li>
<p><code>{m,n}</code>：匹配m-n个字符。在这中间的字符都可以匹配到。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;123&quot;
 ret = re.match('\d{1,2}',text)
 prit(ret.group())
 &gt;&gt; 12
</code></pre>
<p>如果text只有一个字符，那么也可以匹配出来。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;1&quot;
 ret = re.match('\d{1,2}',text)
 prit(ret.group())
 &gt;&gt; 1
</code></pre>
</li>
</ol>
<h3 id="小案例">小案例：</h3>
<ol>
<li>
<p>验证手机号码：手机号码的规则是以<code>1</code>开头，第二位可以是<code>34587</code>，后面那9位就可以随意了。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;18570631587&quot;
 ret = re.match('1[34587]\d{9}',text)
 print(ret.group())
 &gt;&gt; 18570631587
</code></pre>
<p>而如果是个不满足条件的手机号码。那么就匹配不到了。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;1857063158&quot;
 ret = re.match('1[34587]\d{9}',text)
 print(ret.group())
 &gt;&gt; AttributeError: 'NoneType' object has no attribute
</code></pre>
</li>
<li>
<p>验证邮箱：邮箱的规则是邮箱名称是用<code>数字、数字、下划线</code>组成的，然后是<code>@</code>符号，后面就是域名了。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;hynever@163.com&quot;
 ret = re.match('\w+@\w+\.[a-zA-Z\.]+',text)
 print(ret.group())
</code></pre>
</li>
<li>
<p>验证URL：URL的规则是前面是<code>http</code>或者<code>https</code>或者是<code>ftp</code>然后再加上一个冒号，再加上一个斜杠，再后面就是可以出现任意非空白字符了。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;http://www.baidu.com/&quot;
 ret = re.match('(http|https|ftp)://[^\s]+',text)
 print(ret.group())
</code></pre>
</li>
<li>
<p>验证身份证：身份证的规则是，总共有18位，前面17位都是数字，后面一位可以是数字，也可以是小写的x，也可以是大写的X。示例代码如下：</p>
<pre><code class="language-python"> text = &quot;3113111890812323X&quot;
 ret = re.match('\d{17}[\dxX]',text)
 print(ret.group())
</code></pre>
</li>
</ol>
<h3 id="脱字号表示以开始">^（脱字号）：表示以...开始：</h3>
<pre><code class="language-python">text = &quot;hello&quot;
ret = re.match('^h',text)
print(ret.group())
</code></pre>
<p>如果是在中括号中，那么代表的是取反操作.</p>
<h3 id="表示以结束">$：表示以...结束：</h3>
<pre><code class="language-python"># 匹配163.com的邮箱
text = &quot;xxx@163.com&quot;
ret = re.search('\w+@163\.com$',text)
print(ret.group())
&gt;&gt; xxx@163.com
</code></pre>
<h3 id="匹配多个表达式或者字符串">|：匹配多个表达式或者字符串：</h3>
<pre><code class="language-python">text = &quot;hello|world&quot;
ret = re.search('hello',text)
print(ret.group())
&gt;&gt; hello
</code></pre>
<h3 id="贪婪模式和非贪婪模式">贪婪模式和非贪婪模式：</h3>
<p>贪婪模式：正则表达式会匹配尽量多的字符。默认是贪婪模式。<br>
非贪婪模式：正则表达式会尽量少的匹配字符。<br>
示例代码如下：</p>
<pre><code class="language-python">text = &quot;0123456&quot;
ret = re.match('\d+',text)
print(ret.group())
# 因为默认采用贪婪模式，所以会输出0123456
&gt;&gt; 0123456
</code></pre>
<p>可以改成非贪婪模式，那么就只会匹配到0。示例代码如下：</p>
<pre><code class="language-python">text = &quot;0123456&quot;
ret = re.match('\d+?',text)
print(ret.group())
</code></pre>
<h3 id="案例匹配0-100之间的数字">案例：匹配<code>0-100</code>之间的数字：</h3>
<pre><code class="language-python">text = '99'
ret = re.match('[1-9]?\d$|100$',text)
print(ret.group())
&gt;&gt; 99
</code></pre>
<p>而如果<code>text=101</code>，那么就会抛出一个异常。示例代码如下：</p>
<pre><code class="language-python">text = '101'
ret = re.match('[1-9]?\d$|100$',text)
print(ret.group())
&gt;&gt; AttributeError: 'NoneType' object has no attribute 'group'
</code></pre>
<h3 id="转义字符和原生字符串">转义字符和原生字符串：</h3>
<p>在正则表达式中，有些字符是有特殊意义的字符。因此如果想要匹配这些字符，那么就必须使用反斜杠进行转义。比如<code>$</code>代表的是以...结尾，如果想要匹配<code>$</code>，那么就必须使用<code>\$</code>。示例代码如下：</p>
<pre><code class="language-python">text = &quot;apple price is \$99,orange paice is $88&quot;
ret = re.search('\$(\d+)',text)
print(ret.group())
&gt;&gt; $99
</code></pre>
<p>原生字符串：<br>
在正则表达式中，<code>\</code>是专门用来做转义的。在Python中<code>\</code>也是用来做转义的。因此如果想要在普通的字符串中匹配出<code>\</code>，那么要给出四个<code>\</code>。示例代码如下：</p>
<pre><code class="language-python">text = &quot;apple \c&quot;
ret = re.search('\\\\c',text)
print(ret.group())
</code></pre>
<p>因此要使用原生字符串就可以解决这个问题：</p>
<pre><code class="language-python">text = &quot;apple \c&quot;
ret = re.search(r'\\c',text)
print(ret.group())
</code></pre>
<hr>
<h2 id="re模块中常用函数">re模块中常用函数：</h2>
<h3 id="match">match：</h3>
<p>从开始的位置进行匹配。如果开始的位置没有匹配到。就直接失败了。示例代码如下：</p>
<pre><code class="language-python">text = 'hello'
ret = re.match('h',text)
print(ret.group())
&gt;&gt; h
</code></pre>
<p>如果第一个字母不是<code>h</code>，那么就会失败。示例代码如下：</p>
<pre><code class="language-python">text = 'ahello'
ret = re.match('h',text)
print(ret.group())
&gt;&gt; AttributeError: 'NoneType' object has no attribute 'group'
</code></pre>
<p>如果想要匹配换行的数据，那么就要传入一个<code>flag=re.DOTALL</code>，就可以匹配换行符了。示例代码如下：</p>
<pre><code class="language-python">text = &quot;abc\nabc&quot;
ret = re.match('abc.*abc',text,re.DOTALL)
print(ret.group())
</code></pre>
<h3 id="search">search：</h3>
<p>在字符串中找满足条件的字符。如果找到，就返回。说白了，就是只会找到第一个满足条件的。</p>
<pre><code class="language-python">text = 'apple price $99 orange price $88'
ret = re.search('\d+',text)
print(ret.group())
&gt;&gt; 99
</code></pre>
<h3 id="分组">分组：</h3>
<p>在正则表达式中，可以对过滤到的字符串进行分组。分组使用圆括号的方式。</p>
<ol>
<li><code>group</code>：和<code>group(0)</code>是等价的，返回的是整个满足条件的字符串。</li>
<li><code>groups</code>：返回的是里面的子组。索引从1开始。</li>
<li><code>group(1)</code>：返回的是第一个子组，可以传入多个。<br>
示例代码如下：</li>
</ol>
<pre><code class="language-python">text = &quot;apple price is $99,orange price is $10&quot;
ret = re.search(r&quot;.*(\$\d+).*(\$\d+)&quot;,text)
print(ret.group())
print(ret.group(0))
print(ret.group(1))
print(ret.group(2))
print(ret.groups())
</code></pre>
<h3 id="findall">findall：</h3>
<p>找出所有满足条件的，返回的是一个列表。</p>
<pre><code class="language-python">text = 'apple price $99 orange price $88'
ret = re.findall('\d+',text)
print(ret)
&gt;&gt; ['99', '88']
</code></pre>
<h3 id="sub">sub：</h3>
<p>用来替换字符串。将匹配到的字符串替换为其他字符串。</p>
<pre><code class="language-python">text = 'apple price $99 orange price $88'
ret = re.sub('\d+','0',text)
print(ret)
&gt;&gt; apple price $0 orange price $0
</code></pre>
<p><code>sub</code>函数的案例，获取拉勾网中的数据：</p>
<pre><code class="language-python">html = &quot;&quot;&quot;
&lt;div&gt;
&lt;p&gt;基本要求：&lt;/p&gt;
&lt;p&gt;1、精通HTML5、CSS3、 JavaScript等Web前端开发技术，对html5页面适配充分了解，熟悉不同浏览器间的差异，熟练写出兼容各种浏览器的代码；&lt;/p&gt;
&lt;p&gt;2、熟悉运用常见JS开发框架，如JQuery、vue、angular，能快速高效实现各种交互效果；&lt;/p&gt;
&lt;p&gt;3、熟悉编写能够自动适应HTML5界面，能让网页格式自动适应各款各大小的手机；&lt;/p&gt;
&lt;p&gt;4、利用HTML5相关技术开发移动平台、PC终端的前端页面，实现HTML5模板化；&lt;/p&gt;
&lt;p&gt;5、熟悉手机端和PC端web实现的差异，有移动平台web前端开发经验，了解移动互联网产品和行业，有在Android,iOS等平台下HTML5+CSS+JavaScript（或移动JS框架）开发经验者优先考虑；6、良好的沟通能力和团队协作精神，对移动互联网行业有浓厚兴趣，有较强的研究能力和学习能力；&lt;/p&gt;
&lt;p&gt;7、能够承担公司前端培训工作，对公司各业务线的前端（HTML5\CSS3）工作进行支撑和指导。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;岗位职责：&lt;/p&gt;
&lt;p&gt;1、利用html5及相关技术开发移动平台、微信、APP等前端页面，各类交互的实现；&lt;/p&gt;
&lt;p&gt;2、持续的优化前端体验和页面响应速度，并保证兼容性和执行效率；&lt;/p&gt;
&lt;p&gt;3、根据产品需求，分析并给出最优的页面前端结构解决方案；&lt;/p&gt;
&lt;p&gt;4、协助后台及客户端开发人员完成功能开发和调试；&lt;/p&gt;
&lt;p&gt;5、移动端主流浏览器的适配、移动端界面自适应研发。&lt;/p&gt;
&lt;/div&gt;
&quot;&quot;&quot;

ret = re.sub('&lt;/?[a-zA-Z0-9]+&gt;',&quot;&quot;,html)
print(ret)
</code></pre>
<h3 id="split">split：</h3>
<p>使用正则表达式来分割字符串。</p>
<pre><code class="language-python">text = &quot;hello world ni hao&quot;
ret = re.split('\W',text)
print(ret)
&gt;&gt; [&quot;hello&quot;,&quot;world&quot;,&quot;ni&quot;,&quot;hao&quot;]
</code></pre>
<h3 id="compile">compile：</h3>
<p>对于一些经常要用到的正则表达式，可以使用<code>compile</code>进行编译，后期再使用的时候可以直接拿过来用，执行效率会更快。而且<code>compile</code>还可以指定<code>flag=re.VERBOSE</code>，在写正则表达式的时候可以做好注释。示例代码如下：</p>
<pre><code class="language-python">text = &quot;the number is 20.50&quot;
r = re.compile(r&quot;&quot;&quot;
                \d+ # 小数点前面的数字
                \.? # 小数点
                \d* # 小数点后面的数字
                &quot;&quot;&quot;,re.VERBOSE)
ret = re.search(r,text)
print(ret.group())
</code></pre>
]]></content>
    </entry>
</feed>